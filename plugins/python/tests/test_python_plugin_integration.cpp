#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "cserverdc.h"
#include "plugins/python/cpipython.h"
#include "plugins/python/cpythoninterpreter.h"
#include "cconndc.h"
#include "cprotocol.h"
#include <fstream>
#include <string>
#include <vector>
#include <chrono>
#include <unistd.h>  // for getpid()
#include <cstdlib>   // for getenv()

using namespace testing;

// Helper to get env var with default
static std::string getEnvOrDefault(const char* name, const char* defaultValue) {
    const char* value = std::getenv(name);
    return value ? std::string(value) : std::string(defaultValue);
}

// Global server instance (requires MySQL)
static nVerliHub::nSocket::cServerDC* g_server = nullptr;

/*
 * INTEGRATION TEST ENVIRONMENT
 * 
 * This test requires a fully configured Verlihub environment including:
 * - MySQL server running on localhost
 * - Database 'verlihub' created
 * - Verlihub config files in <build_dir>/test_config_<pid>/
 * 
 * The test exercises the full Python plugin stack including:
 * - Loading Python scripts
 * - Message parsing and routing
 * - Python callback invocation through the GIL wrapper
 * - Stress testing with 100K+ iterations
 * 
 * WHY MYSQL IS REQUIRED:
 * The cpiPython::OnLoad() method immediately accesses:
 * - server->mMySQL (line 92 of cpipython.cpp)
 * - server->mC.hub_security (line 96)
 * And cServerDC constructor (line 65 of cserverdc.cpp) connects to MySQL.
 * 
 * Attempted workarounds that failed:
 * - Option 3 (minimal mock): Passing nullptr to OnLoad() causes segfault
 * - The plugin is too deeply coupled to server infrastructure
 * 
 * FUTURE IMPROVEMENT:
 * - Create database abstraction layer to allow mock DB for testing
 * - Refactor plugin initialization to be testable without full server
 */

// Full Verlihub environment setup
class VerlihubEnv : public ::testing::Environment {
public:
    void SetUp() override {
        // Use build directory for config to allow parallel test runs
        std::string config_dir = std::string(BUILD_DIR) + "/test_config_" + 
                                 std::to_string(getpid());
        std::string config_file = config_dir + "/dbconfig";
        std::string plugins_dir = config_dir + "/plugins";
        
        // Create config and plugins directories
        int ret = system(("mkdir -p " + config_dir).c_str());
        (void)ret; // Suppress warning
        ret = system(("mkdir -p " + plugins_dir).c_str());
        (void)ret;
        
        // Get MySQL connection details from environment (for Docker support)
        // or use defaults for local MySQL installation
        std::string db_host = getEnvOrDefault("VH_TEST_MYSQL_HOST", "localhost");
        std::string db_port = getEnvOrDefault("VH_TEST_MYSQL_PORT", "3306");
        std::string db_user = getEnvOrDefault("VH_TEST_MYSQL_USER", "verlihub");
        std::string db_pass = getEnvOrDefault("VH_TEST_MYSQL_PASS", "verlihub");
        std::string db_name = getEnvOrDefault("VH_TEST_MYSQL_DB", "verlihub");
        
        // Construct host:port format if port is not 3306
        std::string db_host_port = db_host;
        if (db_port != "3306") {
            db_host_port = db_host + ":" + db_port;
        }
        
        // Write minimal dbconfig
        std::ofstream dbconf(config_file);
        dbconf << "db_host = " << db_host_port << "\n"
               << "db_user = " << db_user << "\n" 
               << "db_pass = " << db_pass << "\n"
               << "db_data = " << db_name << "\n";
        dbconf.close();
        
        // Create server (connects to MySQL but does NOT start listening on ports)
        try {
            g_server = new nVerliHub::nSocket::cServerDC(config_dir, config_dir);
            // NOTE: We deliberately DO NOT call g_server->StartListening()
            // This allows the server to initialize fully (including loading plugins)
            // without binding to network ports, which would block the test
        } catch (...) {
            throw std::runtime_error(
                "Failed to create Verlihub server!\n\n"
                "This test requires MySQL. Please:\n"
                "1. Install MySQL: sudo apt-get install mysql-server\n"
                "2. Create database: CREATE DATABASE verlihub;\n"
                "3. Create user: CREATE USER 'verlihub'@'localhost' IDENTIFIED BY 'verlihub';\n"
                "4. Grant access: GRANT ALL ON verlihub.* TO 'verlihub'@'localhost';\n"
                "5. Initialize schema: Run verlihub --init\n"
            );
        }
        
        if (!g_server) {
            throw std::runtime_error("Server creation returned null");
        }
    }

    void TearDown() override {
        if (g_server) {
            delete g_server;
            g_server = nullptr;
        }
        // Clean up config directory
        std::string config_dir = std::string(BUILD_DIR) + "/test_config_" + 
                                 std::to_string(getpid());
        int ret = system(("rm -rf " + config_dir).c_str());
        (void)ret; // Suppress warning
    }
};

// Simplified script for testing
const char* script_content = R"python(
import sys

call_counts = {}

def count_call(name):
    call_counts[name] = call_counts.get(name, 0) + 1
    if call_counts[name] % 10000 == 0:
        print(f"{name} called {call_counts[name]} times", file=sys.stderr)
    return 1

def OnNewConn(*args):
    return count_call('OnNewConn')

def OnCloseConn(*args):
    return count_call('OnCloseConn')

def OnParsedMsgChat(*args):
    return count_call('OnParsedMsgChat')

def OnParsedMsgSearch(*args):
    return count_call('OnParsedMsgSearch')

def OnParsedMsgMyINFO(*args):
    return count_call('OnParsedMsgMyINFO')

def OnParsedMsgValidateNick(*args):
    return count_call('OnParsedMsgValidateNick')

def OnParsedMsgSupports(*args):
    return count_call('OnParsedMsgSupports')

def OnParsedMsgVersion(*args):
    return count_call('OnParsedMsgVersion')
)python";

// Test fixture
class VerlihubIntegrationTest : public ::testing::Test {
protected:
    std::string script_path = "./test_script.py";
    nVerliHub::nPythonPlugin::cpiPython* py_plugin = nullptr;

    void SetUp() override {
        // Manually create and register the Python plugin
        // (normally loaded from .so file by PluginManager)
        py_plugin = new nVerliHub::nPythonPlugin::cpiPython();
        py_plugin->OnLoad(g_server);
        
        ASSERT_NE(py_plugin, nullptr) << "Failed to create Python plugin";

        // Write script to file
        std::ofstream script_file(script_path);
        script_file << script_content;
        script_file.close();

        // Load script into interpreter
        nVerliHub::nPythonPlugin::cPythonInterpreter* interp = 
            new nVerliHub::nPythonPlugin::cPythonInterpreter(script_path);
        py_plugin->AddData(interp);
        interp->Init();
    }

    void TearDown() override {
        // Unload script
        if (py_plugin) {
            py_plugin->RemoveByName(script_path);
            delete py_plugin;
            py_plugin = nullptr;
        }
        std::remove(script_path.c_str());
    }

    void SendMessage(nVerliHub::nSocket::cConnDC* conn, const std::string& raw_msg) {
        nVerliHub::nProtocol::cMessageParser* parser = g_server->mP.CreateParser();
        parser->mStr = raw_msg;
        parser->mLen = raw_msg.size();
        parser->Parse();
        
        // This is the core: TreatMsg calls into Python through the GIL wrapper
        g_server->mP.TreatMsg(parser, conn);
        
        g_server->mP.DeleteParser(parser);
    }
};

// Stress test - exercises GIL handling under load
TEST_F(VerlihubIntegrationTest, StressTreatMsg) {
    nVerliHub::nSocket::cConnDC* conn = new nVerliHub::nSocket::cConnDC(0, g_server);
    const int iterations = 100000;

    std::vector<std::string> messages = {
        "$Supports BotINFO HubINFO|",
        "$ValidateNick TestUser|",
        "$Version 1,0091|",
        "$MyINFO $ALL TestUser Desc$ $LAN(T3)l$localhost$0|",
        "<TestUser> test message|",
        "$Search Hub:TestUser F?T?0?9?TTH:AAAA|",
    };

    auto start = std::chrono::high_resolution_clock::now();
    
    for (int i = 0; i < iterations; ++i) {
        SendMessage(conn, messages[i % messages.size()]);
        
        if (i % 10000 == 0) {
            std::cout << "Progress: " << i << " / " << iterations << std::endl;
        }
    }

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    std::cout << "Completed " << iterations << " messages in " 
              << duration.count() << "ms ("
              << (iterations * 1000.0 / duration.count()) << " msg/sec)" << std::endl;

    delete conn;
    EXPECT_TRUE(true);  // Pass if no crash
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    ::testing::AddGlobalTestEnvironment(new VerlihubEnv);
    return RUN_ALL_TESTS();
}
